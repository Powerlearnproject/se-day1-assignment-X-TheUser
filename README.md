[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18407122&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.

Software engineering is the procedure of planning, creating, assessing and servicing software applications. Software engineering plays an important role within the technology industry by empowering the production of software applications and software systems that drive several strands of modern life such as transportation and business growth.

Identify and describe at least three key milestones in the evolution of software engineering.

In the 1960s software engineering was found as a speciality. In the 1960s whilst starting with the instructions and map-reading structures for the Apollo mission, Margaret Hamilton, a computer scientist and systems engineer conceived the name software engineering. She believed that software developers gained the right to be named engineers (Wiliams, 2024). 

In the 1970s there was the emergence organised programming. This time in software engineering initiated a new method of composing software. Organised programming brings attention to rational structures and processes, ensuring that it is simpler to have knowledge of and correct software. At this time, numerous influential programming languages were created such as Fortran by Nicklaus Wirth and C by MacAlistair Richie. The programming languages ensured that it was viable to create compound software, thus pushing the rise of software engineering (Institute of Data, 2024).

In the 2000s there was the emergence of nimble procedures. This time witnessed the establishment of agile methodologies, which focused on fluidity and consumer participation across fixed procedures and recording. Agile methods, such as Extreme Programming (widely known as XP), have developed into being guideline within software development. The methods have assisted in raising the pace and coherence of software development, ensuring that it is viable to bring exceptional software within concise time limits (Institute of Data, 2024).

List and briefly explain the phases of the Software Development Life Cycle.

1. Planning - Interpreting the extent of the design, the targets, the schedule and the means issued.
2. Requirements - Assembling and recording user requirements and system needs.
3. Design - Developing the system structure, user link, and comprehensive scheme records.
4. Implementation - Composing the code and constructing the software based on the scheme's requirements.
5. Testing - Running tests to make sure the software encounters quality standards and practical needs.
6. Deployment - Delivering the software to its targeted users.
7. Maintenance - Providing help to users, updates and improvements to the software after it has been deployed.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
The waterfall method is a project management system that emphasises breaking down a project into linear steps. Therefore, it means that one has to go through one step of the process in order to go through to another step. However, the agile methodology emphasises breaking down a project into phases, referred to as sprints, in order to bring about a software faster. 

As discussed, the waterfall methodology follows a rigid process. So each stage (requirements gathering, design, development, testing, deployment) must be concluded before proceeding to the next phase. The agile method follows an iterative development. The process is broken down into smaller 'sprints' or stages, allowing constant commentary and enhances. The waterfall method restricts feedback loops. Therefore, consumer commentary is gathered when the project is concluded. The agile method allows constant consumer participation. This means that the method allows the consumers to constantly engage in gathering commentary and modifying the project. 

The waterfall method needs comprehensive planning and documentation before the project begins. The agile method allows the teams to modify their concerns and features due to new information. The waterfall method is good for projects with fixed needs, whereby changes are small, and coherent timelines are important. THe agile method is good for projects with undetermined needs, whereby speedy transformation to change is important and customer satisfaction is crucial.

Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

The software developer plans, creates, tests and provides the upkeep or maintenance of the software. The software developer analyses live systems and brings about ideas for enhancing systems. The software developer collaborates with data analysts, designers and staff. They also work with consumers and other engineers to find software needs. They also push knowledge sharing across the whole team and organisation. Along with these, the software developer writes the code for the software, tests the software before distributing it, composes the user training manuals, and does the upkeep of the software once it is distributed.

The quality assurance engineer plans, implements, and leads tests to make sure that the software connects with the quality standards by finding and stating issues. They thus work closely with the software developers to correct the problems, an observing the whole project quality throughout the software development cycle. The quality asurance engineer's main responsibilities include creating test plans, composing test cases, implementing tests, recording issues, and collaborating with the development team to preserve high quality software.

The project manager is integral in managing the project and crucial to the completion of the software project. Project managers are responsible for composing the project proposition, forecasting the project's cost estimations, creating a timetable, predict the staff that will be needed for the project, software procedure customisation, observing and supervising the project, version control management, loss prevention, managerial record writing, addressing, and communicate with clients.

Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

Integrated Development Environments are important in the sense that they give a detailed forum for software developers to compose, test, and troubleshoot code effectively. Therefore, notably amplifying productivity by giving features such as syntax highlighting, code completion, troubleshooting tools, and project management potential, eventually enhancing code quality and simplifying the development process. Examples include Microsoft Visual Studio and IntelliJ IDEA.

Version Control Systems let developers productively trace alterations made to the code over time, warranting flawless participation, avoiding disputes when numerous developers work on the same project, and giving the capability to go back to former versions if needed, effectively enhancing the quality and coherence of the software development process. Examples include GitHub and Azure DevOps.

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.


Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

Unit testing is the excercise of testing the compact testable bits of a software application, named units, on their own to confirm that each part operates as planned and works accurately individually, which assists in finding and correcting bugs in advance during the development process. The importance of unit testing is that it lets developers see and fix issues sooner in the development process, guiding towards enhanced code quality, refined serviceability, and escalated belief in the software by finding problems at the individual component magnitude before they rise into bigger issues, eventually lessening development costs and time used in debugging.

Integration testing is procedure whereby numerous parts are merged and examined jointly to confirm how they connect and work as a reliable system, making sure that data moves accurately between different components of the software application. The importance of integration testing is that it averts possible problems that could surface when components are connected and utilised in unison by users. 

System testing is the procedure whereby the whole software system is tested, analysing its workability, execution, and user encounter to make sure that it meets all the designated needs and works accurately from the user's point of view, finding any bugs or faults that require correction before the software is distributed. The importance of system testing is that it makes sure that the software application meets every workable and non-workable need before being used by the end user, eventually guiding towards a top standard product with less post-release issues and boosted consumer fulfilment. 

Acceptance testing is the procedure whereby the concluded software application is assessed by users or stakeholders to confirm if it meets the designated needs and user requirements, making sure it is prepared for distribution and pleases the target audience when it is distributed. The importance of acceptance testing is that it improves user contentment and reduces dangers linked to initiating a new product.

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

Prompt engineering is the procedure of composing orders to receive the finest answers from an artificial intelligence model. Prompt engineering is important because it lets users successfully convey their objective and preferred result by creating understandable, brief, and relatedly pertinent prompts, guiding towards more precise, pertinent, and employable answers from the artificial intelligence model, fundamentally acting as a connection between human dialect and the artificial intelligence model's abilities.

Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

An example of a vague prompt is "Write a short film script about loss". The improved version would be to say "Write a short script about a man who lost his suburban house due to losing his job and has to go back to his township home to live with his estranged brother". The improved prompt states the setting and the exact topic that the user wants the artificial intelligence model to talk about.
